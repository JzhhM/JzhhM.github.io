# 第6节:内存淘汰策略以及对缓存架构的一些思考.md
>我是jz，从业两年谈过需求，做过设计，组织过系统重构，执着于底层实现，立志做一个造轮子的开发。

## 一、前言
`多思，多想，多学，多做`

这大概是redis专题最后一节了，前前后后大概两个月的时间，从缓存的设计，寻址算法，数据结构到缓存中常见问题，集群部署，早就计划补完
redis的最后一块，因为项目上的一些事一直拖到了现在....

ok，让我们回到正题。redis是完全基于内存的一个数据库，那大家有没有想过，redis是如何清除数据的呢？

## 二、过期策略

###1.定期删除:在redis中，对于设置了ttl的key放在一个独立的字典中，进行周期性扫描
默认会每秒进行十次过期扫描（100ms一次），过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略。
-1.从过期字典中随机 20 个 key；

-2.删除这 20 个 key 中已经过期的 key；

-3.如果过期的 key 比率超过 1/4，那就重复步骤 1；

### 2. 惰性删除

在客户端访问这个key的时候，redis对key的过期时间进行检查，如果过期了就立即删除，不会给你返回任何东西。

因为定期删除的贪心策略会导致很多过期key到了时间并没有被删除掉，所以将删除用在了客户端获取数据时


## 三.淘汰策略

那什么是淘汰策略呢？因为不管是定期采样删除还是惰性删除都不是一种完全精准的删除，当存入新的数据，内存不足是，
就需要淘汰策略进行补充

1. noeviction：默认策略，当内存不足以容纳新写入数据时，新写入操作会报错。
2. volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的key中，根据过期时间进行淘汰，越早过期的优先被淘汰。
3. volatile-random：当内存不足以容纳新写入数据时，从设置了过期时间的key中，随机淘汰数据。
4. allkeys-random：当内存不足以容纳新写入数据时，从所有key中随机淘汰数据。
5. volatile-lru：当内存不足以容纳新写入数据时，从设置了过期时间的key中使用LRU（最近最少使用）算法进行淘汰
6. allkeys-lru：当内存不足以容纳新写入数据时，从所有key中使用LRU（最近最少使用）算法进行淘汰

----------redis 4.0 版本以上新增策略 -------------------
7. volatile-lfu：4.0版本新增，当内存不足以容纳新写入数据时，在过期的key中，使用LFU算法进行删除key。
8. allkeys-lfu：4.0版本新增，当内存不足以容纳新写入数据时，从所有key中使用LFU算法进行淘汰；

## 4.缓存架构设计想法

事前：Redis 高可用，主从+哨兵，Redis cluster，避免全盘崩溃。
事中：本地 ehcache 缓存 + Sentiner 限流+降级，避免数据库被打死。
事后：Redis 持久化 RDB+AOF，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。
